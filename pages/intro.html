<div class="row">

<div class="col-md-10">
<h1 id="q">
<a name="q" class="anchor" href="#q"><span class="octicon octicon-link"></span></a>Q</h1>

<p><em>Q</em> is a data language. For now, it is limited to a data
<em>definition</em> language (DDL). Think "JSON/XML schema", but the correct
way. <em>Q</em> comes with a dedicated type system for defining data and a
theory, called <em>information contracts</em>, for interoperability with
programming and data exchange languages.</p>

<h2 id="example">
<a name="example" class="anchor" href="#example"><span class="octicon octicon-link"></span></a>Example</h2>

<p>Suppose we want to capture information about a medical diagnosis for some patient.
At left, a typical digital document in JSON. At right, the corresponding <em>Q</em> schema.</p>

<div class='row'>
<div class="col-md-6">
<div class="highlight highlight-json"><pre><span class="p">{</span>
  <span class="nt">"patient"</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="s2">"27b3ceb0-7e10-0131-c9f1-3c07545ed162"</span><span class="p">,</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"Marcia Delgados"</span><span class="p">,</span>
    <span class="nt">"dob"</span><span class="p">:</span> <span class="s2">"1975-11-03"</span>
  <span class="p">},</span>
  <span class="nt">"symptoms"</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">"Nausea"</span><span class="p">,</span>
    <span class="s2">"Fever"</span>
  <span class="p">],</span>
  <span class="nt">"temperature"</span><span class="p">:</span> <span class="mf">39.5</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="col-md-6">
<div class="highlight highlight-ruby"><pre><span class="no">Temp</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">celcius</span><span class="o">&gt;</span> <span class="no">Real</span><span class="p">(</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="mi">33</span><span class="o">.</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="mi">45</span><span class="o">.</span><span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">patient</span> <span class="p">:</span> <span class="p">{</span>
    <span class="nb">id</span>   <span class="p">:</span> <span class="no">Uuid</span><span class="p">,</span>
    <span class="nb">name</span> <span class="p">:</span> <span class="nb">String</span><span class="p">(</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">),</span>
    <span class="n">dob</span>  <span class="p">:</span> <span class="no">Date</span><span class="p">(</span> <span class="n">d</span> <span class="o">|</span> <span class="ss">alive</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;</span> <span class="mi">1890</span> <span class="p">),</span>
  <span class="p">},</span>
  <span class="n">symptoms</span> <span class="p">:</span> <span class="o">[</span> <span class="nb">String</span><span class="p">(</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">]</span><span class="p">,</span>
  <span class="n">temperature</span> <span class="p">:</span> <span class="no">Temp</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<p>Suppose an invalid document comes in. With <em>Q</em>, you properly
validate input data and get friendly error messages.</p>

<div class='row'>
<div class="col-md-7">
<pre><code>[patient] Missing attribute `name`
[patient/id] Invalid value `27b3ceb0` for Uuid
[patient/dob] Invalid value `1875-11-03` for Date (not alive)
[symptoms/1] Invalid value "" for String( s | s.size &gt; 0 )
[temperature] Invalid value 12.5 for Temperature (celcius)
</code></pre>
</div>
<div class="col-md-5">
<div class="highlight highlight-json"><pre><span class="p">{</span>
  <span class="nt">"patient"</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="s2">"27b3ceb0"</span><span class="p">,</span>
    <span class="nt">"dob"</span><span class="p">:</span> <span class="s2">"1875-11-03"</span>
  <span class="p">},</span>
  <span class="nt">"symptoms"</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">"Nausea"</span><span class="p">,</span>
    <span class="s2">""</span>
  <span class="p">],</span>
  <span class="nt">"temperature"</span><span class="p">:</span> <span class="mf">12.5</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<h2 id="use-cases">
<a name="use-cases" class="anchor" href="#use-cases"><span class="octicon octicon-link"></span></a>Use cases</h2>

<p><em>Q</em> can be used in many places where data is involved. In particular, it can be used for:</p>

<ul>
  <li><em>Enforcing</em> data types towards more robust and secure (RESTful)
  web-services, configuration files, data exchanges, etc.</li>
  <li><em>Coercing</em> low-level to high-level types when digesting data, to
  palliate the fact that exchange languages have limited type systems (e.g.
  JSON has no builtin time type) and raise the level of abstraction in a safe
  and almost transparent way.</li>
  <li><em>Documenting</em> data types and schemas, in RESTful resource
  definitions, NoSQL document databases, etc.</li>
  <li><em>Mapping</em> data types in heterogeneous environments, towards a
  better and simpler interoperability between databases, various programming
  languages, data exchange languages, etc.</li>
</ul>

<h2 id="implementations">
<a name="implementations" class="anchor" href="#implementations"><span class="octicon octicon-link"></span></a>Implementations</h2>

Obviously the scenarios outlined in previous section require an
implementation, or <em>binding</em> of <em>Q</em>, for the situation at hand.
The following projects provide those bindings so far (<a
href="mailto:blambeau@gmail.com">contact us</a> or fork this page on github to
add your own binding to this list!):

<ul>
  <li><a href="https://github.com/blambeau/qrb">Qrb</a> &mdash; <em>Q</em> in Ruby (data coercing &amp; validation)</li>
  <li><a href="https://github.com/llambeau/qjs">Qjs</a> &mdash; <em>Q</em> in Javascript (under development)</li>
</ul>

<h1 id="information-contracts">
<a name="information-contracts" class="anchor" href="#information-contracts"><span class="octicon octicon-link"></span></a>Information Contracts</h1>

<p><em>Q</em> tries very hard not to be <em>yet another data language</em>. In
particular, it aims at integrating as smoothly as possible with existing
technologies, in particular with programming languages and data exchange
formats (e.g. JSON or YAML).</p>

<p>This interoperability is handled through so-called <em>information
contracts</em>. In some respect, information contracts are the dual of
axiomatic contracts, i.e. the dual of public behavioral APIs of software
abstractions.</p>

<p class="img"><img src="/img/contracts.png"/></p>

<p>For a given software abstraction, say a <code>Color</code>:</p>

<ul>
<li>The <em>axiomatic</em> contract hides the internal representation in favor
of a set of public behavioral methods to manipulate the abstraction (e.g.
darkening and brightening the color),</li>
<li>The <em>information</em> contract hides the internal representation in
favor of a set of public information representations of the abstraction (e.g.
a RGB triple, an hexadecimal string).</li>
</ul>

<p>The data types involved in the definitions of the information contracts are
called <em>information types</em>, e.g. <code>{r: Byte, g: Byte, b:
Byte}</code> (a <a href="#tuple-types">tuple type</a>). <em>Q</em> provides a
<a href="#type-system">rich type system</a> dedicated at capturing those data
types precisely, mostly because type systems of main stream programming
languages fail at providing an good support for them. The interoperability of
<em>Q</em> with those other type systems is covered a bit later.</p>

<h2 id="dressing-undressing">
<a name="dressing-undressing" class="anchor" href="#dressing-undressing"><span class="octicon octicon-link"></span></a>Dressing &amp; Undressing</h1>

<p>In a more precise way, an information contract is actually a set of
functions pairs, such as:</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># RGB information contract</span>
<span class="n">dress</span>   <span class="o">::</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span><span class="no">Byte</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="no">Byte</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="no">Color</span>
<span class="n">undress</span> <span class="o">::</span> <span class="no">Color</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span><span class="no">Byte</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="no">Byte</span><span class="p">}</span>

<span class="c1"># HEX information contract</span>
<span class="n">dress</span>   <span class="o">::</span> <span class="nb">String</span><span class="p">(</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=~</span> <span class="sr">/#[a-z0-9]{6}/</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Color</span>
<span class="n">undress</span> <span class="o">::</span> <span class="no">Color</span> <span class="o">-&gt;</span> <span class="nb">String</span><span class="p">(</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=~</span> <span class="sr">/#[a-z0-9]{6}/</span> <span class="p">)</span>
</pre></div>

<p>In other words, each public data representation of an abstraction comes
with two (pure) functions that allow <em>dressing</em> the corresponding
information type with the abstraction behavior, and <em>undressing</em> the latter
the other way round.</p>

<p>The information contract is required to guarantee <em>information
equivalence</em> of the various representations. Information equivalence is
defined as shown below. This supposes some definition for the two equality
operators involved, e.g. on the abstraction type and the information type,
respectively.</p>

<div class="highlight highlight-ruby"><pre><span class="n">dress</span><span class="p">(</span><span class="n">undress</span><span class="p">(</span><span class="n">adt</span><span class="p">))</span>  <span class="o">=</span> <span class="n">adt</span>
<span class="n">undress</span><span class="p">(</span><span class="n">dress</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">=</span> <span class="n">info</span>
</pre></div>

<h1 id="type-system">
<a name="type-system" class="anchor" href="#type-system"><span class="octicon octicon-link"></span></a>Type System</h1>

<p><em>Q</em>'s type system is different from those you can find in a
programming language. The aim here is to capture <em>information</em>, not
software <em>behavior</em>. Therefore, the definition of <em>type</em>
differs. In <em>Q</em>, a type is a set of values, a subtype is a subset, a
supertype is a superset. That's it.</p>

The point here is <b>not</b> to define yet another type system with a fixed
set of available types such as <code>boolean</code>, <code>string</code> and
<code>integer</code>, but rather to provide an abstract way of building
<em>information types</em> and to 'connect' them to the types available in a
programming language, or data exchange language.

<h2 id="builtin-types">
<a name="builtin-types" class="anchor" href="#builtin-types"><span class="octicon octicon-link"></span></a>Builtin types</h2>

<p>A builtin type starts with a dot and is then denoted by the name of a Ruby
class. E.g.</p>

<div class="highlight highlight-ruby"><pre><span class="o">.</span><span class="n">Integer</span>  <span class="c1"># The set of values captured by Ruby's Integer class</span>
</pre></div>

<p>Importing Q/builtins automatically defines type aliases for most ruby classes.
The dot notation can thus be avoided for them all. We make the assumption that
builtins are imported in the rest of this document and use the same class
names while getting rid of the dot.</p>

<h2 id="sub-types">
<a name="sub-types" class="anchor" href="#sub-types"><span class="octicon octicon-link"></span></a>Sub types</h2>

<p>Sub types are subsets of values. Q uses so-called 'specialization by
constraint' to define sub types. E.g., the set of positive integers can be
defined as follows:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Posint</span> <span class="o">=</span> <span class="nb">Integer</span><span class="p">(</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
</pre></div>

<p>Multiple constraints can be distinguished by name:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Evens</span> <span class="o">=</span> <span class="nb">Integer</span><span class="p">(</span> <span class="n">i</span> <span class="o">|</span> <span class="ss">positive</span><span class="p">:</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">even</span><span class="p">:</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</pre></div>

<p>All types can be sub-typed through constraints. In addition, Q uses structural
type equivalence, which means that the type captured by the definition of
<code>Evens</code> above is actually equivalent to the following one:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Evens</span> <span class="o">=</span> <span class="no">PosInt</span><span class="p">(</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</pre></div>

<h2 id="union-types">
<a name="union-types" class="anchor" href="#union-types"><span class="octicon octicon-link"></span></a>Union types</h2>

<p>In some respect, union types are the dual of subtypes. They allow defining new
types by generalization, through the union of the set of values captured by
other types. For instance, the missing Boolean type of ruby is simply captured
as:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Boolean</span> <span class="o">=</span> <span class="o">.</span><span class="n">TrueClass</span><span class="o">|.</span><span class="n">FalseClass</span>
</pre></div>

<p>Union types are also very useful for capturing possibly missing information
(aka NULL/nil). For instance, the following type will capture either an
integer, or nil (note that <code>Nil = .NilClass</code>).</p>

<div class="highlight highlight-ruby"><pre><span class="no">MaybeInt</span> <span class="o">=</span> <span class="nb">Integer</span><span class="o">|</span><span class="no">Nil</span>
</pre></div>

<h2 id="seq-types">
<a name="seq-types" class="anchor" href="#seq-types"><span class="octicon octicon-link"></span></a>Seq types</h2>

<p>Capturing sequences (aka arrays) of values is straightforward. Sequences are
ordered and may contain duplicates:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Measures</span> <span class="o">=</span> <span class="o">[</span><span class="no">Posint</span><span class="o">]</span>
</pre></div>

<h2 id="set-types">
<a name="set-types" class="anchor" href="#set-types"><span class="octicon octicon-link"></span></a>Set types</h2>

<p>Capturing sets of values is straightforward too. Set are unordered and may not
contain duplicates:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Hobbies</span> <span class="o">=</span> <span class="p">{</span><span class="nb">String</span><span class="p">}</span>
</pre></div>

<h2 id="tuple-types">
<a name="tuple-types" class="anchor" href="#tuple-types"><span class="octicon octicon-link"></span></a>Tuple types</h2>

<p>Tuples capture information facts. Their 'structure' is called <em>heading</em> and is
fixed and known in advance. All attributes are mandatory:</p>

<div class="highlight highlight-ruby"><pre><span class="no">ProgrammingLanguage</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">author</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">since</span><span class="p">:</span> <span class="no">Date</span> <span class="p">}</span>
</pre></div>

<h2 id="relation-types">
<a name="relation-types" class="anchor" href="#relation-types"><span class="octicon octicon-link"></span></a>Relation types</h2>

<p>Relations are sets of tuples, all of same heading. The notation for defining
relation types naturally follows:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Languages</span> <span class="o">=</span> <span class="p">{{</span> <span class="nb">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">author</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">since</span><span class="p">:</span> <span class="no">Date</span> <span class="p">}}</span>
</pre></div>

<p>Relation types and their syntax are first-class in Q, most notably because
of the availability of relational algebra for them, unlike pure sets of
tuples.</p>

<p>Note that relations do not allow duplicates and have no significant ordering
of their tuples. If the ordering is significant for you, want should consider
a sequence of tuples instead:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Preferences</span> <span class="o">=</span> <span class="o">[</span><span class="p">{</span> <span class="ss">lang</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">reason</span><span class="p">:</span> <span class="nb">String</span> <span class="p">}</span><span class="o">]</span>
</pre></div>

<h2 id="abstract-data-types">
<a name="abstract-data-types" class="anchor" href="#abstract-data-types"><span class="octicon octicon-link"></span></a>Abstract Data types</h2>

<p>Abstract data types, also called user-defined types, provide the way to
define higher level abstractions easily and to optionally connect them to
types of the host language (e.g. a ruby class). For instance, a
<code>Color</code> abstraction can be defined as follows:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Color</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">rgb</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="no">Byte</span><span class="p">},</span>
        <span class="o">&lt;</span><span class="n">hex</span><span class="o">&gt;</span> <span class="nb">String</span><span class="p">(</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=~</span> <span class="sr">/^#[0-9a-f]{6}$/i</span> <span class="p">)</span>
</pre></div>

<p>The Color definition above shows that a color can be represented either by
a RGB triple (through a tuple type), or by a hexadecimal string (e.g. #8a2be2).
<code>rgb</code> and <code>hex</code> are called the <strong>information
representations</strong> of the Color abstraction.</p>

<h3 id="adt-and-host">
<a name="adt-and-host" class="anchor" href="#adt-and-host"><span class="octicon octicon-link"></span></a>Binding an ADT to the host language</h3>

<p>Defined as above, the type will behave as a union type, i.e. it will let
pass valid RGB triples and hexadecimal strings. Now, representations can be
complemented to connect the Color abstraction to a host language type, e.g. a
Color ruby class, and raise the level of discourse on the programming side.
This amounts at providing one information contract per representation.</p>

<p>Suppose for example that the following <code>Color</code> class has been defined:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Color</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="vi">@r</span><span class="p">,</span> <span class="vi">@g</span><span class="p">,</span> <span class="vi">@b</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span>
  <span class="k">end</span>
  <span class="kp">attr_reader</span> <span class="ss">:r</span><span class="p">,</span> <span class="ss">:g</span><span class="p">,</span> <span class="ss">:b</span>

<span class="k">end</span>
</pre></div>

<p>Connecting our information ADT to this Color class can be done through a
builtin type and two explicit converters, called the <em>dresser</em> and the
<em>undresser</em>: (We only show the <code>rgb</code> case here, the
<code>hex</code> one is defined in a similar way)</p>

<div class="highlight highlight-ruby"><pre><span class="no">Color</span> <span class="o">=</span> <span class="o">.</span><span class="n">Color</span> <span class="o">&lt;</span><span class="n">rgb</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="no">Byte</span><span class="p">}</span>
          <span class="p">\(</span> <span class="n">tuple</span> <span class="o">|</span> <span class="no">Color</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">tuple</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">tuple</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">tuple</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="p">)</span>
          <span class="p">\(</span> <span class="n">color</span> <span class="o">|</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="n">color</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span> <span class="n">color</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="n">color</span><span class="o">.</span><span class="n">b</span><span class="p">}</span> <span class="p">)</span>
</pre></div>

<p>The converters provide load/dump code to convert from information types to
the code abstraction and vice versa, thereby complementing a representation
with an information contract. A binding of <em>Q</em>, e.g. Qrb, guarantees
that the dresser will only be executed on valid representations of the
corresponding information type. As the dresser tends to be exposed to an
unsafe world, however, it should always be kept <em>pure and safe</em> (no
side effect, no metaprogramming, no code evaluation, etc.).</p>

<h3 id="adt-and-host-contracts">
<a name="adt-and-host-contracts" class="anchor" href="#adt-and-host"><span class="octicon octicon-link"></span></a>Host ADT protocols</h3>

<p>In order to keep <em>Q</em> schemas as clean as possible, implementations
may provide conventions-over-configuration protocols for automating
information contracts.</p>

<p>For instance, Qrb provides a more idiomatic way of connecting ruby classes
to information types. The information contracts may indeed be moved to the
class itself, as one would probably do it, e.g. for testing purpose.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Color</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="vi">@r</span><span class="p">,</span> <span class="vi">@g</span><span class="p">,</span> <span class="vi">@b</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span>
  <span class="k">end</span>
  <span class="kp">attr_reader</span> <span class="ss">:r</span><span class="p">,</span> <span class="ss">:g</span><span class="p">,</span> <span class="ss">:b</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">rgb</span><span class="p">(</span><span class="n">tuple</span><span class="p">)</span>
    <span class="no">Color</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">tuple</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">tuple</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">tuple</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_rgb</span>
    <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="vi">@r</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span> <span class="vi">@g</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="vi">@b</span><span class="p">}</span>
  <span class="k">end</span>

<span class="k">end</span>
</pre></div>

<p>In Qrb, the following definition, that refers to the builtin type but has
no dresser/undresser, makes the assumption that the convention is met and
will use the <code>Color.rgb(...)</code> and <code>Color#to_rgb</code>
methods:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Color</span> <span class="o">=</span> <span class="o">.</span><span class="n">Color</span> <span class="o">&lt;</span><span class="n">rgb</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">r</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">g</span><span class="p">:</span> <span class="no">Byte</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="no">Byte</span><span class="p">}</span>
</pre></div>
</div>

<div class="col-md-2">
<div class="menu">
  <ul class="nav">
    <li>
      <a href="#q"><em>Q</em> &mdash; A Data Language</a>
      <ul class="nav">
        <li>
          <a href="#example">Example</a>
        </li>
        <li>
          <a href="#use-cases">Use cases</a>
        </li>
        <li>
          <a href="#implementations">Implementations</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#information-contracts">Information Contracts</a>
      <ul class="nav">
        <li>
          <a href="#dressing-undressing">Dressing/Undressing</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#type-system">Type System</a>
      <ul class="nav">
        <li><a href="#builtin-types">Builtins</a></li>
        <li><a href="#sub-types">Subtypes</a></li>
        <li><a href="#union-types">Unions</a></li>
        <li><a href="#seq-types">Sequences</a></li>
        <li><a href="#set-types">Sets</a></li>
        <li><a href="#tuple-types">Tuples</a></li>
        <li><a href="#relation-types">Relations</a></li>
        <li><a href="#abstract-data-types">ADTs</a></li>
      </ul>
    </li>
  </ul>
</div>

</div>
</div>